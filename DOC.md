
# TODO List 项目说明文档

## 1. 技术选型

### **1.1 后端技术栈**

- **编程语言**：**Java 17**
  - **理由**：作为一名 Java 开发者，Java 拥有我最熟练的生态系统和工具链。Java 17 作为 LTS 版本，在性能、稳定性和语法特性之间取得了很好的平衡。
- **Web 框架**：**Spring Boot 3.x**
  - **理由**：Spring Boot 的“约定优于配置”特性极大地简化了应用的搭建过程。它内置了 Tomcat 容器，配合 Spring MVC 可以快速构建标准的 RESTful API，非常适合本次时间紧迫的开发任务。
- **持久层**：**Spring Data JPA (Hibernate)**
  - **理由**：Spring Data JPA 提供了极简的 Repository 接口抽象，自动生成大量 CRUD 代码，让我能专注于业务逻辑。底层 Hibernate 自动处理 ORM 映射，大大减少了手动编写 SQL 的工作量。
- **数据库**：**SQLite**
  - **理由**：
    - **零配置**：无需安装和配置额外的数据库服务器，数据存储在本地 `.db` 文件中，随项目一起移动，极易部署和演示。
    - **持久化能力**：相比 H2 内存数据库，SQLite 能将数据持久化到磁盘，重启应用数据不丢失，符合项目对持久化的要求。

### **1.2 前端技术栈**

- **技术栈**：**原生 HTML5, CSS3, JavaScript**
  - **理由**：虽然 React/Vue 是主流，但对于本项目“后端为主，前端为辅”的定位，引入复杂的构建工具链会增加不必要的复杂度。原生技术栈足以构建一个响应迅速、交互友好的单页面应用（SPA），且便于直接通过 Spring Boot 静态资源服务进行部署。

### **1.3 替代方案对比**

- **为什么不用 MongoDB**：待办事项具有非常清晰且固定的结构（标题、描述、状态、优先级），关系型数据库的强类型和事务支持更适合此类数据。且 SQLite 比 MongoDB 更轻量，不需要运行后台服务进程。
- **为什么不用 Thymeleaf**：为了贯彻“前后端分离”的架构思想。虽然 Thymeleaf 是服务端渲染的好选择，但使用 RESTful API + 静态 HTML 页面能更好地解耦前后端，未来前端可以无缝迁移到 Vue 或 React。

## 2. 项目结构设计

### **2.1 整体架构**

本项目采用经典的分层架构（Layered Architecture）：

1.  **表现层 (Controller)**：暴露 RESTful API，处理 HTTP 请求与响应。
2.  **业务层 (Service)**：封装核心业务逻辑（如排序策略、状态流转）。
3.  **持久层 (Repository)**：负责与 SQLite 数据库交互。
4.  **前端层**：通过 Fetch API 与后端通信，动态渲染 DOM。

### **2.2 目录结构**

```text
src/main/java/com/zhyuan/todolist/
├── controller/
│   └── TodoController.java         # API 入口，处理 /api/todos 请求
├── service/
│   └── TodoService.java            # 业务逻辑核心，处理排序、搜索组合
├── repository/
│   └── TodoRepository.java         # 数据访问接口，包含自定义 JPQL 查询
├── model/
│   ├── Todo.java                   # 数据库实体，映射 todos 表
│   ├── Priority.java               # [枚举] 任务优先级 (HIGH, MEDIUM, LOW)
│   ├── TodoCreateRequest.java      # DTO: 用于创建任务
│   ├── TodoFullUpdateRequest.java  # DTO: 用于完整编辑
│   ├── TodoUpdateRequest.java      # DTO: 用于状态切换
│   └── TodoResponse.java           # DTO: 统一响应格式
├── exception/
│   └── ResourceNotFoundException.java # 自定义异常
└── ToDoListApplication.java        # 启动类

src/main/resources/
├── static/                         # 前端静态资源
│   ├── demo.html                  # 单页面应用入口
│   ├── style.css                   # 样式表 (包含响应式设计)
│   └── script.js                   # 前端交互逻辑 (Fetch API 封装)
└── application.properties          # 数据库与日志配置
|
├──README.md						#简要说明运行方式
├──DOC.md							#TODO List 项目说明文档
```



## 3. 需求细节与决策

本章节详细阐述了在开发过程中针对核心功能的设计思路，以及对未来可扩展功能的架构预演。

### **3.1 核心功能设计与实现思路**

#### **1. 数据模型与交互设计**

- **输入校验策略**：
  - **设计思路**：为了保证数据的脏数据不进入数据库，采用 **后端为主，前端为辅** 的双重校验策略。
  - **实现**：后端使用 @NotBlank 拦截非法请求，前端通过 HTML5 required 属性提供即时反馈，减少无效的网络请求。
- **DTO 模式应用**：
  - **设计思路**：为了实现 **数据库模型的解耦**，避免直接暴露实体类（Entity）可能导致的安全问题（如恶意修改自增 ID 或时间戳）。
  - **实现**：设计了 TodoCreateRequest（仅包含业务字段）、TodoResponse（包含元数据）等 DTO，确保每一层的数据传输都是精确且安全的。

#### **2. 优先级系统设计**

- **设计思路**：优先级不应仅仅是前端显示的标签，更应参与业务逻辑（排序）。
- **决策**：放弃使用简单的数字（1, 2, 3）或字符串，而是使用 Java **枚举 (Enum)**。
  - **理由**：枚举提供了强类型安全，防止了非法值的录入，且易于维护。
- **排序难点与解决**：
  - **问题**：数据库默认按字符串字典序排序 (HIGH -> LOW -> MEDIUM)，这不符合逻辑顺序。
  - **解决方案**：在 Repository 层使用自定义 JPQL 查询，利用 CASE WHEN 语句将枚举映射为逻辑权重（HIGH=0, MEDIUM=1, LOW=2），从而实现 **高->中->低** 的正确排序。

#### **3. 高级搜索与动态排序**

- **设计思路**：随着任务数量增加，前端过滤和排序的性能会下降，因此必须在 **数据库层面** 完成筛选和排序。
- **实现**：
  - 搜索功能利用 SQL 的 LIKE %keyword% 实现模糊匹配。
  - 排序功能通过 Spring Data JPA 的 Sort 对象实现动态字段排序，结合自定义 SQL 实现复杂的优先级排序逻辑。

### **3.2 未来扩展功能的架构思考 (暂未实现)**

虽然本项目因时间限制未实现以下功能，但基于当前的架构，我已经有了清晰的技术实现路线图：

#### **1. 提醒与通知功能**

- **需求**：在任务截止时间到达时提醒用户。
- **技术方案**：
  - **后端调度**：使用 Spring 的 @Scheduled ，定期扫描数据库中即将过期的任务。
  - **消息推送**：
    - **实时通知**：引入 **WebSocket**，建立服务器与浏览器的长连接，实现弹窗提醒。

#### **2. 多设备协作与数据同步**

- **需求**：用户在手机端修改任务，PC 端实时更新；防止多人修改同一任务导致数据覆盖。
- **技术方案**：
  - **乐观锁 (Optimistic Locking)**：在 Todo 实体中增加 @Version 版本号字段。当两个请求同时修改同一数据时，版本号较旧的请求会被拒绝，提示用户“数据已过期，请刷新后重试”。
  - **WebSocket 广播**：当一个客户端修改数据成功后，服务器通过 WebSocket 向所有在线客户端广播变更事件，触发前端自动刷新。

#### **4. 任务分类 (Categories/Tags)**

- **需求**：任务可以归类为“工作”、“生活”等，且一个任务可能属于多个标签。
- **技术方案**：
  - **数据库设计**：采用 **多对多 (Many-to-Many)** 关系。
    - 新增 Category 表。
    - 新增关联表 todo_category。
  - **JPA 映射**：在 Todo 实体中使用 @ManyToMany 注解关联 Category 实体。



## 4. AI 使用说明

本项目在开发过程中适度使用了 AI 工具（主要为Gemini）辅助开发，具体如下：

- **代码片段生成**：
  - 使用 AI 生成了 前端代码。
  - 使用AI辅助生成了 `TodoRepository` 中复杂的 Query语句。
  - 使用AI辅助生成了一些不常见语法的编写。
- **Bug 定位与修复**：
  - **数据库字段缺失**：在添加 `priority` 字段后遇到 SQLite 报错，AI 提示需要删除旧 `.db` 文件以触发 Hibernate 的 `ddl-auto` 重建表结构。
  - **前端状态 Bug**：在复用弹窗时，点击“新增”会错误覆盖“编辑”的数据。AI 帮助定位到 `input type="hidden"` 未清空的问题，并给出了 `modalTodoId.value = ''` 的修复方案。
- **AI 方案修正**：
  - 初始 AI 建议仅使用简单的 JPA 方法命名查询，但我发现无法处理复杂的“优先级自定义排序”，因此改用了 `@Query` 手写 JPQL 实现。
  - 初始 AI 建议选型为 H2 数据库，考虑到项目的展示及未来可用性问题，选择使用轻便的SQLite作为数据库交互。
  - 初始 AI 给出代码中并未实现模糊查询，后自行改为模糊查询优化使用体验。
  - 前端最初建议使用简单的 `alert` 提示错误，后改为在控制台输出并在 UI 上体现（如空状态提示），提升体验。

## 5. 运行与测试方式

### **5.1 环境要求**

- JDK 17+
- Maven 3.x

### **5.2 运行步骤**

1. **启动后端**：

   在 IDE 中直接运行 `ToDoListApplication` 类。

2. **访问应用**：
   打开浏览器访问 `http://localhost:8080/demo.html`。

3. **数据库**：
   应用启动后会在根目录自动生成 `todos.db` 文件。

### **5.3 已完成测试**

- **功能测试**：覆盖了 CRUD、搜索、筛选、所有排序模式、状态切换。
- **边界测试**：测试了空标题提交（被拦截）、特殊字符搜索、无数据时的空状态显示。
- **浏览器兼容性**：在 Chrome 和 Edge 最新版上测试通过。

## 6. 总结与反思

### **6.1 项目亮点**

- **完成度高**：不仅实现了基础 CRUD，还完成了优先级管理、自定义排序、模糊搜索等进阶功能。
- **用户体验佳**：虽然没有使用前端框架，但通过 CSS3 和原生 JS 实现了弹窗、动画、相对时间等现代 Web 应用的体验。
- **代码规范**：后端严格遵循 RESTful 规范，代码分层清晰，使用了 DTO 模式避免实体泄露。

### **6.2 如果有更多时间，我会改进...**

- **数据库迁移**：引入 Flyway 来管理数据库版本，而不是在开发阶段简单粗暴地删除 `.db` 文件。
- **安全性**：引入 Spring Security 实现用户登录和数据隔离，使应用支持多用户。
- **API 文档**：集成 SpringDoc (Swagger) 自动生成在线 API 文档。
- **前端框架**：当交互逻辑进一步复杂时，会考虑迁移到 React 或 Vue 以获得更好的组件化开发体验。